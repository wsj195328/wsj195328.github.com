<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>课程5.UITextField使用</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><img src="http://static.zybuluo.com/zhuoming/9y9ocj9x0iw2k87m7br254g1/logo.png" width="300" height="100"><span style="float:right;" data-anchor-id="8zmj"><b>求知若渴 求真教育</b></span><div class="md-section-divider"></div><h1 data-anchor-id="svgr" id="课程5uitextfield使用">课程5.UITextField使用</h1><div class="md-section-divider"></div><h2 data-anchor-id="sxic" id="ios-ui"><code>iOS</code> <code>UI</code></h2><p data-anchor-id="0od4"><div class="toc"><div class="toc">
<ul>
<li><a href="#课程5uitextfield使用">课程5.UITextField使用</a><ul>
<li><a href="#ios-ui">iOS UI</a></li>
<li><a href="#一学习目标">一、学习目标</a></li>
<li><a href="#二课程内容">二、课程内容</a><ul>
<li><a href="#1uitextfield的创建">1.UITextField的创建</a></li>
<li><a href="#2uitextfield的代理">2.UITextField的代理</a></li>
<li><a href="#3键盘处理">3.键盘处理</a></li>
</ul>
</li>
<li><a href="#三课堂练习">三、课堂练习</a></li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="8np1" id="一学习目标"><strong>一、学习目标</strong></h2><ul data-anchor-id="hlmu">
<li>UITextField的使用</li>
<li>学会处理键盘的遮挡</li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="mjex" id="二课程内容"><strong>二、课程内容</strong></h2><div class="md-section-divider"></div><h3 data-anchor-id="9s77" id="1uitextfield的创建"><strong>1.UITextField的创建</strong></h3><p data-anchor-id="ih4s">还记得在学习Objective-C的时候，我们通过控制台向系统输入数据和展示数据。现在阶段我们可以通过用UILabel展示文字、通过UIImageView展示图片、通过UIButton接受用户的点击输入，今天我们将要的学习UITextField是输入框，可以接受用户的文本输入。</p><blockquote data-anchor-id="f9ye" class="white-blockquote">
  <p><i class="icon-apple"></i>  <strong>tips</strong> <br>
  使用xib或者storyBoard可以快速查看UITextField的各项属性及功能</p>
</blockquote><table data-anchor-id="g2o2" class="table table-striped-white table-bordered">
<thead>
<tr>
 <th>常用属性</th>
 <th style="text-align:center;">说明</th>
 <th>详细说明</th>
</tr>
</thead>
<tbody><tr>
 <td>Placeholder</td>
 <td style="text-align:center;">可以在文本框中显示灰色的字</td>
 <td>用于提示用户应该在这个文本框输入什么内容。当这个文本框中输入了数据时，用于提示的灰色的字将会自动消失。</td>
</tr>
<tr>
 <td>Disabled</td>
 <td style="text-align:center;">若选中此项，用户将不能更改文本框内容。</td>
 <td></td>
</tr>
<tr>
 <td>接下来是三个按钮</td>
 <td style="text-align:center;">用来设置对齐方式。</td>
 <td></td>
</tr>
<tr>
 <td>Border Style</td>
 <td style="text-align:center;">选择边界风格</td>
 <td></td>
</tr>
<tr>
 <td>Clear Button</td>
 <td style="text-align:center;">清除按钮就是出一个现在文本框右边的小 X</td>
 <td>Never appears ： 从不出现  Appears while editing ： 编辑时出现   Appears unless editing   Is always visible ： 总是可见</td>
</tr>
<tr>
 <td>Clear when editing begins</td>
 <td style="text-align:center;">若选中此项，则当开始编辑这个文本框时，文本框中之前的内容会被清除掉。</td>
 <td>比如，你现在这个文本框 A 中输入了 "What" ，之后去编辑文本框 B，若再回来编辑文本框 A ，则其中的"What" 会被立即清除</td>
</tr>
<tr>
 <td>Text Color</td>
 <td style="text-align:center;">设置文本框中文本的颜色</td>
 <td></td>
</tr>
<tr>
 <td>Font</td>
 <td style="text-align:center;">设置文本的字体与字号。</td>
 <td></td>
</tr>
<tr>
 <td>Min Font Size</td>
 <td style="text-align:center;">设置文本框可以显示的最小字体（不过我感觉没什么用）</td>
 <td></td>
</tr>
<tr>
 <td>Adjust To Fit</td>
 <td style="text-align:center;">指定当文本框尺寸减小时，文本框中的文本是否也要缩小</td>
 <td>选择它，可以使得全部文本都可见，即使文本很长。但是这个选项要跟 Min Font Size 配合使用，文本再缩小，也不会小于设定的 Min Font Size 。</td>
</tr>
<tr>
 <td>Captitalization</td>
 <td style="text-align:center;">设置大写。</td>
 <td>None ： 不设置大写   Words ： 每个单词首字母大写，这里的单词指的是以空格分开的字符串  Sentances ： 每个句子的第一个字母大写，这里的句子是以句号加空格分开的字符串   All Characters ： 所以字母大写</td>
</tr>
<tr>
 <td>Correction</td>
 <td style="text-align:center;">检查拼写，默认是 YES 。</td>
 <td></td>
</tr>
<tr>
 <td>Keyboard</td>
 <td style="text-align:center;">选择键盘类型，比如全数字、字母和数字等</td>
 <td></td>
</tr>
<tr>
 <td>Return Key</td>
 <td style="text-align:center;">选择返回键</td>
 <td>可以选择 Search 、 Return 、 Done 等。</td>
</tr>
<tr>
 <td>Auto-enable Return Key</td>
 <td style="text-align:center;">如选择此项，则只有至少在文本框输入一个字符后键盘的返回键才有效。</td>
 <td></td>
</tr>
<tr>
 <td>Secure</td>
 <td style="text-align:center;">当你的文本框用作密码输入框时，可以选择这个选项，此时，字符显示为星号。</td>
 <td></td>
</tr>
</tbody></table><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7221"><ol class="linenums"><li class="L0"><code><span class="pln"> </span><span class="com">//初始化textfield并设置位置及大小</span></code></li><li class="L1"><code><span class="typ">UITextField</span><span class="pln"> </span><span class="pun">*</span><span class="pln">tf1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[[</span><span class="typ">UITextField</span><span class="pln"> alloc</span><span class="pun">]</span><span class="pln">initWithFrame</span><span class="pun">:</span><span class="typ">CGRectMake</span><span class="pun">(</span><span class="lit">20</span><span class="pun">,</span><span class="pln"> </span><span class="lit">20</span><span class="pun">,</span><span class="pln"> </span><span class="lit">130</span><span class="pun">,</span><span class="pln"> </span><span class="lit">30</span><span class="pun">)];</span></code></li><li class="L2"><code><span class="com">//设置边框样式，只有设置了才会显示边框样式</span></code></li><li class="L3"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">borderStyle </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UITextBorderStyleRoundedRect</span><span class="pun">;</span></code></li><li class="L4"><code><span class="com">//设置输入框的背景颜色，此时设置为白色 枚举 如果使用了自定义的背景图片边框会被忽略掉</span></code></li><li class="L5"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">backgroundColor </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIColor</span><span class="pln"> whiteColor</span><span class="pun">];</span></code></li><li class="L6"><code><span class="com">//当输入框没有内容时，灰色字体提示 提示内容为password</span></code></li><li class="L7"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">placeholder </span><span class="pun">=</span><span class="pln"> </span><span class="pun">@</span><span class="str">"password"</span><span class="pun">;</span></code></li><li class="L8"><code><span class="com">//设置输入框内容的字体样式和大小</span></code></li><li class="L9"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">font </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIFont</span><span class="pln"> fontWithName</span><span class="pun">:@</span><span class="str">"Arial"</span><span class="pln"> size</span><span class="pun">:</span><span class="lit">20.0f</span><span class="pun">];</span></code></li><li class="L0"><code><span class="com">//设置字体颜色</span></code></li><li class="L1"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">textColor </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIColor</span><span class="pln"> redColor</span><span class="pun">];</span></code></li><li class="L2"><code><span class="com">//输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容 </span></code></li><li class="L3"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">clearButtonMode </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UITextFieldViewModeAlways</span><span class="pun">;</span></code></li><li class="L4"><code><span class="com">//输入框中一开始就有的文字</span></code></li><li class="L5"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">text </span><span class="pun">=</span><span class="pln"> </span><span class="pun">@</span><span class="str">"一开始就在输入框的文字"</span><span class="pun">;</span></code></li><li class="L6"><code><span class="com">//每输入一个字符就变成点 用语密码输入</span></code></li><li class="L7"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">secureTextEntry </span><span class="pun">=</span><span class="pln"> YES</span><span class="pun">;</span></code></li><li class="L8"><code><span class="com">//是否纠错</span></code></li><li class="L9"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">autocorrectionType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UITextAutocorrectionTypeNo</span><span class="pun">;</span></code></li><li class="L0"><code><span class="com">//再次编辑就清空</span></code></li><li class="L1"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">clearsOnBeginEditing </span><span class="pun">=</span><span class="pln"> YES</span><span class="pun">;</span></code></li><li class="L2"><code><span class="com">//内容对齐方式</span></code></li><li class="L3"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">textAlignment </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UITextAlignmentLeft</span><span class="pun">;</span></code></li><li class="L4"><code><span class="com">//内容的垂直对齐方式  </span></code></li><li class="L5"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">minimumFontSize </span><span class="pun">=</span><span class="pln"> </span><span class="lit">20</span><span class="pun">;</span></code></li><li class="L6"><code><span class="com">//设置键盘的样式</span></code></li><li class="L7"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">keyboardType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UIKeyboardTypeNumberPad</span><span class="pun">;</span></code></li><li class="L8"><code><span class="com">//首字母是否大写</span></code></li><li class="L9"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">autocapitalizationType </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UITextAutocapitalizationTypeNone</span><span class="pun">;</span></code></li><li class="L0"><code><span class="com">//return键变成什么键</span></code></li><li class="L1"><code><span class="pln">tf1</span><span class="pun">.</span><span class="pln">returnKeyType </span><span class="pun">=</span><span class="typ">UIReturnKeyDone</span><span class="pun">;</span></code></li><li class="L2"><code><span class="com">//键盘外观默认外观，浅灰色</span></code></li><li class="L3"><code><span class="pln">textView</span><span class="pun">.</span><span class="pln">keyboardAppearance</span><span class="pun">=</span><span class="typ">UIKeyboardAppearanceDefault</span><span class="pun">;</span></code></li><li class="L4"><code><span class="com">//设置代理 用于实现协议</span></code></li><li class="L5"><code><span class="pln">tf1</span><span class="pun">.</span><span class="kwd">delegate</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">;</span></code></li><li class="L6"><code><span class="com">//把textfield加到视图中</span></code></li><li class="L7"><code><span class="pun">[</span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view addSubview</span><span class="pun">:</span><span class="pln">tf1</span><span class="pun">];</span></code></li></ol></pre><p data-anchor-id="x501"><img src="http://static.zybuluo.com/zhuoming/8dszshkeuuov07u1gk999ktu/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-29%20%E4%B8%8B%E5%8D%882.40.40.png" alt="屏幕快照 2016-01-29 下午2.40.40.png-38.4kB" title=""></p><div class="md-section-divider"></div><h3 data-anchor-id="6ch6" id="2uitextfield的代理"><strong>2.UITextField的代理</strong></h3><p data-anchor-id="8mj3">UITextField与UIButton一样继承于UIControl,都可以与用户交互，不同的是一旦UITextField获得焦点,系统会根据UITextField的设置弹出不同的键盘。通常的我们需要监听UITextField的输入情况，比如当用户点击了某个UITextField，我们需要判断弹起的键盘是否会挡住视图。这时候我们可以通过实现UITextField的代理来实现对其的监听。</p><p data-anchor-id="jp33">让我们来看一下<code>&lt;UITextFieldDelegate&gt;</code>里面的方法</p><p data-anchor-id="02kr">返回一个BOOL值，指定是否循序文本字段开始编辑</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="mwsc"><ol class="linenums"><li class="L0"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">BOOL</span><span class="pun">)</span><span class="pln">textFieldShouldBeginEditing</span><span class="pun">:(</span><span class="typ">UITextField</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">textField</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> YES</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="cqwj">开始编辑时触发，文本字段将成为first responder</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bi1e"><ol class="linenums"><li class="L0"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">textFieldDidBeginEditing</span><span class="pun">:(</span><span class="typ">UITextField</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">textField</span><span class="pun">{}</span></code></li></ol></pre><p data-anchor-id="8xve">返回BOOL值，指定是否允许文本字段结束编辑，当编辑结束，文本字段会让出first responder <br>
要想在用户结束编辑时阻止文本字段消失，可以返回NO <br>
这对一些文本字段必须始终保持活跃状态的程序很有用，比如即时消息</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="vybw"><ol class="linenums"><li class="L0"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">BOOL</span><span class="pun">)</span><span class="pln">textFieldShouldEndEditing</span><span class="pun">:(</span><span class="typ">UITextField</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">textField</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> NO</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="ufkk">当用户使用自动更正功能，把输入的文字修改为推荐的文字时，就会调用这个方法。 <br>
这对于想要加入撤销选项的应用程序特别有用 <br>
可以跟踪字段内所做的最后一次修改，也可以对所有编辑做日志记录,用作审计用途。 <br>
要防止文字被改变可以返回NO <br>
这个方法的参数中有一个NSRange对象，指明了被改变文字的位置，建议修改的文本也在其中</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="st5m"><ol class="linenums"><li class="L0"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">BOOL</span><span class="pun">)</span><span class="pln">textField</span><span class="pun">:(</span><span class="typ">UITextField</span><span class="pun">*)</span><span class="pln">textField shouldChangeCharactersInRange</span><span class="pun">:(</span><span class="typ">NSRange</span><span class="pun">)</span><span class="pln">range replacementString</span><span class="pun">:(</span><span class="typ">NSString</span><span class="pln"> </span><span class="pun">*)</span><span class="kwd">string</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> YES</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="5bb3">返回一个BOOL值指明是否允许根据用户请求清除内容 <br>
可以设置在特定条件下才允许清除内容</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="kndu"><ol class="linenums"><li class="L0"><code><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">BOOL</span><span class="pun">)</span><span class="pln">textFieldShouldClear</span><span class="pun">:(</span><span class="typ">UITextField</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">textField</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> YES</span><span class="pun">;</span></code></li><li class="L2"><code><span class="pun">}</span><span class="pln"> </span></code></li></ol></pre><p data-anchor-id="4hui">返回一个BOOL值，指明是否允许在按下回车键时结束编辑 <br>
如果允许要调用resignFirstResponder 方法，这回导致结束编辑，而键盘会被收起[textField resignFirstResponder]; <br>
查一下resign这个单词的意思就明白这个方法了</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="661f"><ol class="linenums"><li class="L0"><code><span class="pun">-(</span><span class="pln">BOOL</span><span class="pun">)</span><span class="pln">textFieldShouldReturn</span><span class="pun">:(</span><span class="typ">UITextField</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">textField</span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> YES</span><span class="pun">;</span><span class="pln">  </span></code></li><li class="L2"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="9i9r" id="3键盘处理"><strong>3.键盘处理</strong></h3><ol data-anchor-id="fu3a">
<li>注册通知监听 </li>
</ol><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="96v6"><ol class="linenums"><li class="L0"><code><span class="pun">[[</span><span class="typ">NSNotificationCenter</span><span class="pln"> defaultCenter</span><span class="pun">]</span><span class="pln"> addObserver</span><span class="pun">:</span><span class="kwd">self</span><span class="pln"> selector</span><span class="pun">:</span><span class="lit">@selector</span><span class="pun">(</span><span class="pln">keyBoardChangeFrame</span><span class="pun">:)</span><span class="pln"> name</span><span class="pun">:</span><span class="typ">UIKeyboardWillChangeFrameNotification</span><span class="pln"> </span><span class="kwd">object</span><span class="pun">:</span><span class="kwd">nil</span><span class="pun">];</span></code></li></ol></pre><ol data-anchor-id="2uim">
<li>触发的方法</li>
</ol><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="8tik"><ol class="linenums"><li class="L0"><code><span class="com">/**</span></code></li><li class="L1"><code><span class="com"> *  根据键盘弹起的高度刷新</span></code></li><li class="L2"><code><span class="com"> */</span></code></li><li class="L3"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">keyBoardChangeFrame</span><span class="pun">:(</span><span class="typ">NSNotification</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">noti</span></code></li><li class="L4"><code><span class="pun">{</span></code></li><li class="L5"><code><span class="pln">    </span><span class="com">// 观察里面信息可以获得事件和frme</span></code></li><li class="L6"><code><span class="pln">    </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"userInfo = %@"</span><span class="pun">,</span><span class="pln">noti</span><span class="pun">.</span><span class="pln">userInfo</span><span class="pun">);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="typ">CGFloat</span><span class="pln"> time </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">noti</span><span class="pun">.</span><span class="pln">userInfo</span><span class="pun">[@</span><span class="str">"UIKeyboardAnimationDurationUserInfoKey"</span><span class="pun">]</span><span class="pln"> doubleValue</span><span class="pun">];</span></code></li><li class="L8"><code><span class="pln">    </span><span class="typ">CGRect</span><span class="pln"> keyBoardFrame </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">noti</span><span class="pun">.</span><span class="pln">userInfo</span><span class="pun">[@</span><span class="str">"UIKeyboardFrameEndUserInfoKey"</span><span class="pun">]</span><span class="pln"> </span><span class="typ">CGRectValue</span><span class="pun">];</span></code></li><li class="L9"><code><span class="pln">    </span><span class="com">// 找当前的第一响应者</span></code></li><li class="L0"><code><span class="pln">    </span><span class="typ">UIView</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> fistResponder </span><span class="pun">;</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">UIView</span><span class="pln"> </span><span class="pun">*</span><span class="pln">subView </span><span class="kwd">in</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">subviews</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">([</span><span class="pln">subView isFirstResponder</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">            fistResponder </span><span class="pun">=</span><span class="pln"> subView</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pln">            </span><span class="kwd">break</span><span class="pun">;</span></code></li><li class="L5"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L6"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L7"><code><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fistResponder </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">nil</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L8"><code><span class="pln">        </span><span class="kwd">return</span><span class="pun">;</span></code></li><li class="L9"><code><span class="pln">    </span><span class="pun">}</span></code></li><li class="L0"><code><span class="pln">    </span><span class="com">// 如果响应者的底边 大于 键盘的Y   ==&gt; 也就是挡住</span></code></li><li class="L1"><code><span class="pln">    </span><span class="pun">[</span><span class="typ">UIView</span><span class="pln"> animateWithDuration</span><span class="pun">:</span><span class="pln">time animations</span><span class="pun">:^{</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">        </span><span class="com">// 第一响应者的底部 到 view的底部的距离   减去  keyboard的高度</span></code></li><li class="L4"><code><span class="pln">        </span><span class="typ">CGFloat</span><span class="pln"> offset </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">frame</span><span class="pun">.</span><span class="pln">size</span><span class="pun">.</span><span class="pln">height </span><span class="pun">-</span><span class="pln"> </span><span class="typ">CGRectGetMaxY</span><span class="pun">(</span><span class="pln">fistResponder</span><span class="pun">.</span><span class="pln">frame</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> keyBoardFrame</span><span class="pun">.</span><span class="pln">size</span><span class="pun">.</span><span class="pln">height</span><span class="pun">-</span><span class="lit">50</span><span class="pun">;</span></code></li><li class="L5"><code><span class="pln">        </span><span class="com">/**</span></code></li><li class="L6"><code><span class="com">         *  对接近底部的textFiel 进行容错</span></code></li><li class="L7"><code><span class="com">         */</span></code></li><li class="L8"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fabs</span><span class="pun">(</span><span class="pln">offset</span><span class="pun">)&gt;</span><span class="pln">fabs</span><span class="pun">(</span><span class="pln">keyBoardFrame</span><span class="pun">.</span><span class="pln">size</span><span class="pun">.</span><span class="pln">height</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L9"><code><span class="pln">            offset</span><span class="pun">+=</span><span class="lit">50</span><span class="pun">;</span></code></li><li class="L0"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L1"><code><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">CGRectGetMaxY</span><span class="pun">(</span><span class="pln">fistResponder</span><span class="pun">.</span><span class="pln">frame</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> keyBoardFrame</span><span class="pun">.</span><span class="pln">origin</span><span class="pun">.</span><span class="pln">y </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code><span class="pln">            </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">frame </span><span class="pun">=</span><span class="pln"> </span><span class="typ">CGRectMake</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> offset</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">frame</span><span class="pun">.</span><span class="pln">size</span><span class="pun">.</span><span class="pln">width</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">frame</span><span class="pun">.</span><span class="pln">size</span><span class="pun">.</span><span class="pln">height</span><span class="pun">);</span></code></li><li class="L3"><code><span class="pln">        </span><span class="pun">}</span><span class="kwd">else</span><span class="pun">{</span></code></li><li class="L4"><code><span class="pln">            </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">frame </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">bounds</span><span class="pun">;</span></code></li><li class="L5"><code><span class="pln">        </span><span class="pun">}</span></code></li><li class="L6"><code><span class="pln">    </span><span class="pun">}];</span></code></li><li class="L7"><code><span class="pun">}</span></code></li></ol></pre><blockquote data-anchor-id="myae" class="white-blockquote">
  <p><i class="icon-apple"></i>  Tips <br>
  私有API会导致上架被拒 <br>
     <del>~  UIView * fistResponder = [[[UIApplication sharedApplication] keyWindow] performSelector:@selector(firstResponder)]; ~</del></p>
</blockquote><div class="md-section-divider"></div><h2 data-anchor-id="338q" id="三课堂练习"><strong>三、课堂练习</strong></h2><blockquote data-anchor-id="1n50" class="white-blockquote">
  <p>根据以下效果图实现登录功能跳转功能。请仔细观察效果图，严格按照效果图来实现。</p>
</blockquote><p data-anchor-id="081o"><img src="http://static.zybuluo.com/zhuoming/zme488czn2rnnoncame94ujd/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-29%20%E4%B8%8B%E5%8D%883.59.17.png" alt="屏幕快照 2016-01-29 下午3.59.17.png-35.3kB" title=""></p></div>
</body>
</html>