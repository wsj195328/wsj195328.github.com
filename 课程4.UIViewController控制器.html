<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>课程4.UIViewController控制器</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><img src="http://static.zybuluo.com/zhuoming/9y9ocj9x0iw2k87m7br254g1/logo.png" width="300" height="100"><span style="float:right;" data-anchor-id="vba7"><b>求知若渴 求真教育</b></span><div class="md-section-divider"></div><h1 data-anchor-id="jyzt" id="课程4uiviewcontroller控制器">课程4.UIViewController控制器</h1><p data-anchor-id="gscy"><code>iOS</code> <code>UI</code> <code>新研科技</code></p><hr><p data-anchor-id="fvu3"><div class="toc"><div class="toc">
<ul>
<li><a href="#课程4uiviewcontroller控制器">课程4.UIViewController控制器</a><ul>
<li><a href="#一学习目标">一、学习目标</a></li>
<li><a href="#二课程内容">二、课程内容</a><ul>
<li><a href="#1uiviewcontroller介绍">1.UIViewController介绍</a></li>
<li><a href="#2uiviewcontroller的创建">2.UIViewController的创建</a></li>
<li><a href="#3uiviewcontroller的生命周期">3.UIViewController的生命周期</a></li>
<li><a href="#4多个uiviewcontroller切换">4.多个UIViewController切换</a></li>
<li><a href="#5页面间的传值">5.页面间的传值</a><ul>
<li><a href="#方法一属性传值">方法一：属性传值</a></li>
<li><a href="#方法二代理传值">方法二：代理传值</a></li>
<li><a href="#方法三通知传值">方法三：通知传值</a></li>
<li><a href="#方法四block传值">方法四：Block传值</a></li>
<li><a href="#方法五nsuserdefault">方法五：NSUserDefault</a></li>
<li><a href="#方法六单例传值">方法六：单例传值</a></li>
</ul>
</li>
<li><a href="#三课堂作业">三.课堂作业</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="re64" id="一学习目标"><strong>一、学习目标</strong></h2><ul data-anchor-id="mmvt">
<li>理解为什么需要UIViewController</li>
<li>UIViewController如何关联UIWindow</li>
<li>子类化UIViewController（不带xib）</li>
<li>掌握视图控制器编程模型</li>
<li>UIViewController生命周期</li>
<li>深入多个UIViewController之间界面切换</li>
<li>如何分布多个页面到不同页面中</li>
<li>导航控制器基本使用</li>
<li>导航控制器的视图切换</li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="vh5s" id="二课程内容"><strong>二、课程内容</strong></h2><div class="md-section-divider"></div><h3 data-anchor-id="j1e1" id="1uiviewcontroller介绍"><strong>1.UIViewController介绍</strong></h3><p data-anchor-id="7da7">做多页面时候，所有的代码都放在self.window上太不方便了，不利于程序模块化、独立化。这就是为什么需要UIViewController。 <br>
  就iOS开发来说，UIViewController就最核心的类型之一。而iOS的整个UI开发的核心思想也是MVC的架构，从UIViewController的命名就可以看出它在MVC中所扮演的角色，那就是其中的“C”--Controller。 <br>
<strong>MVC逻辑图</strong> <br>
  <img src="http://static.zybuluo.com/zhuoming/xhqoo6vvpr6dxr5wbo23ud58/2013120612.png" alt="2013120612.png-43.3kB" title=""></p><p data-anchor-id="9qu8"><strong>UIWindow、UiView、UIViewController的关系如下图所示</strong></p><p data-anchor-id="njbc"><img src="http://static.zybuluo.com/zhuoming/7yp6ni3vfqh74n1yb6s4nagu/1366022316_4937.png" alt="1366022316_4937.png-218.5kB" title=""></p><div class="md-section-divider"></div><h3 data-anchor-id="xr5v" id="2uiviewcontroller的创建"><strong>2.UIViewController的创建</strong></h3><p data-anchor-id="693y">在第一章我们手动创建了UIWindow外，还创建了一个UIViewController，并把他设置成了window的rootViewController,现在我们来详细了解这两行代码的作用。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="30a6"><ol class="linenums"><li class="L0"><code><span class="typ">UIViewController</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> vc </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIViewController</span><span class="pln"> </span><span class="kwd">new</span><span class="pun">];</span></code></li><li class="L1"><code><span class="pln">    </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">window</span><span class="pun">.</span><span class="pln">rootViewController </span><span class="pun">=</span><span class="pln"> vc</span><span class="pun">;</span></code></li></ol></pre><p data-anchor-id="h1uv">UIViewController 有多种创建方式，以上是纯代码创建。它还可以通过xib、storyboard等方式创建（这两个后面的章节会详细讲解）。</p><div class="md-section-divider"></div><h3 data-anchor-id="icdb" id="3uiviewcontroller的生命周期"><strong>3.UIViewController的生命周期</strong></h3><p data-anchor-id="qv02">我们在Objective-C的学习中知道一个对象的可以通过 <code>[[NSObject alloc] init]</code> 进行分配内存和初始化。而当对象销毁时系统会自动调用<code>[NSObject dealloc]</code>方法。而UIViewController的生命周期则具有更多的细节，当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</p><blockquote data-anchor-id="0orb" class="white-blockquote">
  <p>1、 <strong>alloc</strong>                                   创建对象，分配空间 <br>
  2、<strong>init (initWithNibName)</strong> 初始化对象，初始化数据,调用init时候self.view还没有分配空间 <br>
  3、<strong>loadView</strong>          UIViewController自带了一个默认的View，我们自定义的UI控件通常添加到上面，从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图 <br>
  4、<strong>viewDidLoad</strong>                   载入完成，可以进行自定义数据以及动态创建其他控件，在声明周期中只会执行一次。 <br>
  5、<strong>viewWillAppear</strong>              视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了，每次将要出现都会执行，在这个函数中可以进行视图的刷新。 <br>
  6、<strong>viewDidAppear</strong>               视图已在屏幕上渲染完成</p>
</blockquote><p data-anchor-id="ot91">当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</p><blockquote data-anchor-id="5mfn" class="white-blockquote">
  <p>1、<strong>viewWillDisappear</strong>            视图将被从屏幕上移除之前执行 <br>
  2、<strong>viewDidDisappear</strong>             视图已经被从屏幕上移除，用户看不到这个视图了 <br>
  3、<strong>dealloc</strong>                                 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放</p>
</blockquote><p data-anchor-id="mch9">通过对生命周期的了解，我们知道我们可以将UI控件的初始化函数放到<strong>viewDidLoad</strong>中，这样既不会多次实例化，而且在显示之前就初始化好了。</p><div class="md-section-divider"></div><h3 data-anchor-id="wh4t" id="4多个uiviewcontroller切换"><strong>4.多个UIViewController切换</strong></h3><p data-anchor-id="jayg">绝大部分的App不止一个界面，所以多个UIViewController切换就特别重要，现在我们来学习其中一种名叫模态（modal）的方法。</p><blockquote data-anchor-id="azlq" class="white-blockquote">
  <p>「 Talk is cheap. Show me the code 」</p>
</blockquote><ul data-anchor-id="01ze">
<li>1.新建两个UIViewController分别叫<strong>VC1</strong>和<strong>VC2</strong></li>
<li>2.在AppDelegate中将VC1设置成window的rootViewController</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="k5tl"><ol class="linenums"><li class="L0"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">BOOL</span><span class="pun">)</span><span class="pln">application</span><span class="pun">:(</span><span class="typ">UIApplication</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">application didFinishLaunchingWithOptions</span><span class="pun">:(</span><span class="typ">NSDictionary</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">launchOptions </span><span class="pun">{</span></code></li><li class="L1"><code><span class="pln">    </span><span class="com">// 当前屏幕的尺寸</span></code></li><li class="L2"><code><span class="pln">    </span><span class="typ">CGRect</span><span class="pln"> frame </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIScreen</span><span class="pln"> mainScreen</span><span class="pun">].</span><span class="pln">bounds</span><span class="pun">;</span></code></li><li class="L3"><code><span class="pln">    </span><span class="com">// 创建一个uiwindow</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">window </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[[</span><span class="typ">UIWindow</span><span class="pln"> alloc</span><span class="pun">]</span><span class="pln">initWithFrame</span><span class="pun">:</span><span class="pln">frame</span><span class="pun">];</span></code></li><li class="L5"><code><span class="pln">    </span><span class="com">// 配置window的属性 背景色设置成紫色</span></code></li><li class="L6"><code><span class="pln">    </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">window</span><span class="pun">.</span><span class="pln">backgroundColor </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIColor</span><span class="pln"> purpleColor</span><span class="pun">];</span></code></li><li class="L7"><code><span class="pln">    </span><span class="com">// 成为主窗口 并显示</span></code></li><li class="L8"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pun">.</span><span class="pln">window makeKeyAndVisible</span><span class="pun">];</span></code></li><li class="L9"><code><span class="pln">    </span><span class="com">// 创建一个VC1</span></code></li><li class="L0"><code><span class="pln">    VC1 </span><span class="pun">*</span><span class="pln"> vc </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">VC1 </span><span class="kwd">new</span><span class="pun">];</span></code></li><li class="L1"><code><span class="pln">    </span><span class="com">// 将VC1的view 背景色设置成白色。大家试试不添加这一句会出现什么效果</span></code></li><li class="L2"><code><span class="pln">    vc</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">backgroundColor </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIColor</span><span class="pln"> whiteColor</span><span class="pun">];</span></code></li><li class="L3"><code><span class="pln">    </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">window</span><span class="pun">.</span><span class="pln">rootViewController </span><span class="pun">=</span><span class="pln"> vc</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">return</span><span class="pln"> YES</span><span class="pun">;</span></code></li><li class="L5"><code><span class="pun">}</span></code></li></ol></pre><ul data-anchor-id="u5hu">
<li>3.在VC1中添加一个按钮，并给按钮添加事件用来跳转到VC2，请看代码示范。</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bb3r"><ol class="linenums"><li class="L0"><code><span class="pln"> VC2 </span><span class="pun">*</span><span class="pln"> vc </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[[</span><span class="pln">VC2 alloc</span><span class="pun">]</span><span class="pln">init</span><span class="pun">];</span></code></li><li class="L1"><code><span class="pln"> vc</span><span class="pun">.</span><span class="pln">view</span><span class="pun">.</span><span class="pln">backgroundColor </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="typ">UIColor</span><span class="pln"> yellowColor</span><span class="pun">];</span></code></li><li class="L2"><code><span class="com">// 通过modalTransitionStyle属性来设置不同的动画</span></code></li><li class="L3"><code><span class="pln">vc</span><span class="pun">.</span><span class="pln">modalTransitionStyle </span><span class="pun">=</span><span class="pln"> </span><span class="typ">UIModalTransitionStyleFlipHorizontal</span><span class="pun">;</span></code></li><li class="L4"><code><span class="pun">[</span><span class="kwd">self</span><span class="pln"> presentViewController</span><span class="pun">:</span><span class="pln">vc   </span><span class="com">// 目标VC对象</span></code></li><li class="L5"><code><span class="pln">                   animated</span><span class="pun">:</span><span class="pln">YES  </span><span class="com">// 是否需要动画</span></code></li><li class="L6"><code><span class="pln">                 completion</span><span class="pun">:^{</span><span class="pln">   </span><span class="com">// 跳转完成后的回调</span></code></li><li class="L7"><code><span class="pln">                     </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"VC1跳转VC2完成"</span><span class="pun">);</span></code></li><li class="L8"><code><span class="pln">                              </span><span class="pun">}];</span></code></li></ol></pre><ul data-anchor-id="obyl">
<li>4.在VC2中添加一个按钮，用来返回上一个界面。</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="s0ra"><ol class="linenums"><li class="L0"><code><span class="pln"> </span><span class="pun">[</span><span class="kwd">self</span><span class="pln"> dismissViewControllerAnimated</span><span class="pun">:</span><span class="pln">YES completion</span><span class="pun">:^{</span></code></li><li class="L1"><code><span class="pln">        </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"返回完成的回调"</span><span class="pun">);</span></code></li><li class="L2"><code><span class="pln">    </span><span class="pun">}];</span></code></li></ol></pre><p data-anchor-id="0udb">效果如下 <br>
<img src="http://static.zybuluo.com/zhuoming/f7jhd5deamb2n2llxthz4d1b/%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC.gif" alt="页面跳转.gif-183.1kB" title=""></p><div class="md-section-divider"></div><h3 data-anchor-id="dfd3" id="5页面间的传值"><strong>5.页面间的传值</strong></h3><p data-anchor-id="eeru">由于不同的UIViewController切换，不同页面间的传值必不可少，接下来我们来学习几种常用页面间的传值方式。我们知道不同的页面也是实例对象，那让我们回忆在Objective-C阶段学习的对象间传值的各种方法。分别有属性传值、代理传值、通知传值、Block传值、NSUserDefault、单例传值。</p><div class="md-section-divider"></div><h4 data-anchor-id="vyqd" id="方法一属性传值">方法一：<strong>属性传值</strong></h4><blockquote data-anchor-id="apli" class="white-blockquote">
  <p>属性传值试用于两个关联性比较强的页面之间使用比如<strong>A页面跳转到B页面</strong></p>
</blockquote><p data-anchor-id="twbs">在B页面的控制器中，编写对应的属性，在A页面跳转到B页面的地方，给B的属性赋值即可。通常称这种情况为顺传。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="06e5"><ol class="linenums"><li class="L0"><code><span class="com">//B_VC.h</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="lit">@property</span><span class="pun">(</span><span class="pln">nonatomic</span><span class="pun">)</span><span class="pln"> </span><span class="typ">NSInteger</span><span class="pln"> flag</span><span class="pun">;</span><span class="com">//暴露在.h中才能被外部访问</span></code></li></ol></pre><p data-anchor-id="zoeg">在A页面的试图控制器中</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="zbxo"><ol class="linenums"><li class="L0"><code><span class="com">//A_VC.m</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">gotoB_VC</span><span class="pun">:(</span><span class="pln">id</span><span class="pun">)</span><span class="pln">sender </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    B_VC </span><span class="pun">*</span><span class="pln">vc </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[[</span><span class="pln">B_VC alloc</span><span class="pun">]</span><span class="pln"> init</span><span class="pun">];</span></code></li><li class="L4"><code><span class="pln">    </span><span class="com">// 属性传值</span></code></li><li class="L5"><code><span class="pln">    vc</span><span class="pun">.</span><span class="pln">flag </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L6"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pln"> presentViewController</span><span class="pun">:</span><span class="pln">vc animated</span><span class="pun">:</span><span class="pln">YES completion</span><span class="pun">:</span><span class="kwd">nil</span><span class="pun">];</span></code></li><li class="L7"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="0mqb" id="方法二代理传值">方法二：<strong>代理传值</strong></h4><blockquote data-anchor-id="7hiw" class="white-blockquote">
  <p>相较于方法一的属性传值，代理传值更适用<strong>与A页面跳转到B页面，B页面再跳转回A页面，并传值</strong>。</p>
</blockquote><p data-anchor-id="je4h">实现原理是 在A成为B的代理，并实现代理方法，在B返回上个页面前，调用代理方法来实现传值。 <br>
<img src="http://static.zybuluo.com/zhuoming/xqc08uph5hxwjadyhj5uighu/575661-20151204113013143-898015979.jpg" alt="575661-20151204113013143-898015979.jpg-26.1kB" title=""></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="l8jd"><ol class="linenums"><li class="L0"><code><span class="com">// B_VC.m</span></code></li><li class="L1"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">back</span></code></li><li class="L2"><code><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    </span><span class="com">//B的代理是A</span></code></li><li class="L4"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pun">.</span><span class="kwd">delegate</span><span class="pln"> postValue</span><span class="pun">:@</span><span class="str">"来自B页面的值"</span><span class="pun">];</span></code></li><li class="L5"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pln"> dismissViewControllerAnimated</span><span class="pun">:</span><span class="pln">YES completion</span><span class="pun">:^{</span></code></li><li class="L6"><code><span class="pln">        </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"返回完成的回调"</span><span class="pun">);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="pun">}];</span></code></li><li class="L8"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="8oza" id="方法三通知传值">方法三：<strong>通知传值</strong></h4><blockquote data-anchor-id="zez7" class="white-blockquote">
  <p>通知传值一般应用于多个接受对象，比如之前的练习VC1、VC2和VC3。从VC3往VC1和VC2同时传递值。需要注意的是：一定要先监听，并且监听的对象已经创建，对象销毁是要移除监听。</p>
</blockquote><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="xjer"><ol class="linenums"><li class="L0"><code><span class="com">// VC3.m</span></code></li><li class="L1"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">back</span></code></li><li class="L2"><code><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    </span><span class="pun">[[</span><span class="typ">NSNotificationCenter</span><span class="pln"> defaultCenter</span><span class="pun">]</span><span class="pln">postNotificationName</span><span class="pun">:@</span><span class="str">"VC3"</span><span class="pln"> </span><span class="kwd">object</span><span class="pun">:@</span><span class="str">"来自VC3的问候"</span><span class="pun">];</span></code></li><li class="L4"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pln"> dismissViewControllerAnimated</span><span class="pun">:</span><span class="pln">YES completion</span><span class="pun">:^{</span></code></li><li class="L5"><code><span class="pln">        </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"返回完成的回调"</span><span class="pun">);</span></code></li><li class="L6"><code><span class="pln">    </span><span class="pun">}];</span></code></li><li class="L7"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="pe9t" id="方法四block传值">方法四：<strong>Block传值</strong></h4><blockquote data-anchor-id="plrx" class="white-blockquote">
  <p><strong>与A页面跳转到B页面，B页面再跳转回A页面并通过Block传值</strong></p>
</blockquote><p data-anchor-id="xzhw">分析思路如下 <br>
1. B拥有一个Block,在A跳转B之前给B的block属性赋值。 <br>
2. B返回A之前调用Block。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="73yk"><ol class="linenums"><li class="L0"><code><span class="com">//B_VC.h</span></code></li><li class="L1"><code><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">(^</span><span class="typ">CallBack</span><span class="pun">)(</span><span class="typ">NSString</span><span class="pln"> </span><span class="pun">*</span><span class="pln">str</span><span class="pun">);</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="com">//B_VC.h</span></code></li><li class="L4"><code><span class="lit">@property</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nonatomic</span><span class="pun">,</span><span class="pln"> copy</span><span class="pun">)</span><span class="pln"> </span><span class="typ">CallBack</span><span class="pln"> block</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="a1mo"><ol class="linenums"><li class="L0"><code><span class="com">//A_VC.m</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">gotoB_VC</span><span class="pun">:(</span><span class="pln">id</span><span class="pun">)</span><span class="pln">sender </span><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    B_VC </span><span class="pun">*</span><span class="pln">vc </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[[</span><span class="pln">B_VC alloc</span><span class="pun">]</span><span class="pln"> init</span><span class="pun">];</span></code></li><li class="L4"><code><span class="pln">    </span><span class="com">// 属性传值</span></code></li><li class="L5"><code><span class="pln">    vc</span><span class="pun">.</span><span class="pln">block </span><span class="pun">=</span><span class="pln"> </span><span class="pun">^(</span><span class="typ">NSString</span><span class="pln"> </span><span class="pun">*</span><span class="pln">str</span><span class="pun">){</span></code></li><li class="L6"><code><span class="pln">        </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"传过来的值是%@"</span><span class="pun">,</span><span class="pln">str</span><span class="pun">);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="pun">};</span></code></li><li class="L8"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pln"> presentViewController</span><span class="pun">:</span><span class="pln">vc animated</span><span class="pun">:</span><span class="pln">YES completion</span><span class="pun">:</span><span class="kwd">nil</span><span class="pun">];</span></code></li><li class="L9"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="b21h"><ol class="linenums"><li class="L0"><code><span class="com">// B_VC.m</span></code></li><li class="L1"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln">back</span></code></li><li class="L2"><code><span class="pun">{</span></code></li><li class="L3"><code><span class="pln">    </span><span class="com">//调用Block</span></code></li><li class="L4"><code><span class="pln">    </span><span class="kwd">self</span><span class="pun">.</span><span class="pln">block</span><span class="pun">(@</span><span class="str">"来自B_VC"</span><span class="pun">);</span></code></li><li class="L5"><code><span class="pln">    </span><span class="pun">[</span><span class="kwd">self</span><span class="pln"> dismissViewControllerAnimated</span><span class="pun">:</span><span class="pln">YES completion</span><span class="pun">:^{</span></code></li><li class="L6"><code><span class="pln">        </span><span class="typ">NSLog</span><span class="pun">(@</span><span class="str">"返回完成的回调"</span><span class="pun">);</span></code></li><li class="L7"><code><span class="pln">    </span><span class="pun">}];</span></code></li><li class="L8"><code><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h4 data-anchor-id="7nlb" id="方法五nsuserdefault">方法五：<strong>NSUserDefault</strong></h4><blockquote data-anchor-id="fjfn" class="white-blockquote">
  <p>这里对UserDefault，等归档类型的具体使用方法不多做赘述。需要注意的是userDefault等类型的传值相较于上面的四种方法有<strong>延时性</strong>、<strong>全局性</strong>、<strong>持久性</strong>,适用于缓存一些全局多处使用，不局限于UIViewController之间的使用。</p>
</blockquote><div class="md-section-divider"></div><h4 data-anchor-id="241d" id="方法六单例传值">方法六：<strong>单例传值</strong></h4><blockquote data-anchor-id="w0cx" class="white-blockquote">
  <p>这里单例如何传值也不赘述，值得一提的是我们第一章学习过的UIApplication是个单例，同样的AppDelegate也是个单例。所以我们可以利用这个现成的单例来实现传值。</p>
</blockquote><p data-anchor-id="d87s">在AppDelegate.h中声明一个指针</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="5r18"><ol class="linenums"><li class="L0"><code><span class="com">// 用来实现传值</span></code></li><li class="L1"><code><span class="lit">@property</span><span class="pun">(</span><span class="pln">nonatomic</span><span class="pun">,</span><span class="pln">copy</span><span class="pun">)</span><span class="typ">NSString</span><span class="pun">*</span><span class="pln"> value</span><span class="pun">;</span></code></li></ol></pre><p data-anchor-id="jek8">用以下代码来获取AppDelegate</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="k6cl"><ol class="linenums"><li class="L0"><code><span class="typ">AppDelegate</span><span class="pln"> </span><span class="pun">*</span><span class="pln">appdelegate </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">AppDelegate</span><span class="pln"> </span><span class="pun">*)[[</span><span class="typ">UIApplication</span><span class="pln"> sharedApplication</span><span class="pun">]</span><span class="pln"> </span><span class="kwd">delegate</span><span class="pun">];</span><span class="pln"> </span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="mk1m" id="三课堂作业"><strong>三.课堂作业</strong></h3><blockquote data-anchor-id="kny6" class="white-blockquote">
  <ul>
  <li><p>新建一个名为VC1的UIViewController，将之前的UI练习放到VC1中。</p></li>
  <li><p>新建3个UIViewController分别叫<strong>VC1</strong>、<strong>VC2</strong>和<strong>VC3</strong>，用不同的颜色或者用Label区分,实现以下功能：</p>
  
  <ol><li>从VC1跳转至VC2</li>
  <li>在VC2可以选择返回VC1,或者跳转至VC3.</li>
  <li>在VC3可以返回VC2.</li></ol></li>
  <li><p>观察各个VC的生命周期</p></li>
  <li>利用上面的例子实现不同页面间的传值。</li>
  </ul>
</blockquote></div>
</body>
</html>